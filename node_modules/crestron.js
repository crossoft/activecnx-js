var events  = require('events');
var net     = require('net');
var util    = require('util');

/**
 * Creates a new `Connection` object capable of communicating with
 * Crestron ActiveCNX devices. This constructor does _not_ initiate a
 * connection attempt; the user must call the `connect()` method after
 * subscribing to any desired events. The connection parameters passed
 * to the constructor are optional. If omitted, they should be passed to
 * the `connect()` method instead; parameters passed to `connect()`
 * override those specified here.
 *
 * @param {String} [hostname] The IP address or hostname of the remote
 *     device.
 * @param {number} [ipid] The remote device's "IPID" identifier.
 * @param {String} [username] The optional authentication username.
 * @param {String} [password] The optional authentication password.
 * @param {number} [port] The port number of the remote device.
 * @param {boolean} [ssl] `true` to use SSL (NOT SUPPORTED; IGNORED).
 * @param {number} [hbInterval] The interval at which to send heartbeat
 *     packets to the remote device, in milliseconds. This value is
 *     optional and defaults to 1000 milliseconds.
 * @param {number} [hbTimeout] Abort the connection if a heartbeat packet
 *     is not received from the remote device within this time interval,
 *     in milliseconds. This value is otpional and defaults to 3000
 *     milliseconds.
 *
 * @classdesc
 *
 * The `crestron.Connection` class mananges a network connection to a
 * remote Crestron device using the ActiveCNX network protocol. The
 * class provides methods to connect to, send commands to, and receive
 * data from the remote device.
 *
 * @constructor Connection
 */
var Connection = function(hostname, ipid, username, password, port,
        ssl, hbInterval, hbTimeout) {

    /**
     * This event is raised when a `Connection` is successfully 
     * established. This event means that valid packets have been
     * received from the remote device and that a valid connection
     * handle has been received.
     *
     * @event Connection#connect
     */

    /**
     * This event is raised when a `Connection` is closed, or when a
     * connection attempt fails.
     *
     * @event Connection#close
     */

    /**
     * This event is raised when an error occurs, either while 
     * establishing a connection or while the connection is active.
     *
     * @event Connection#error
     * @param {Error} err An `Error` object describing the error.
     */

    /**
     * This event is raised when digital (discrete) input data is
     * received from the remote device.
     *
     * @event Connection#digital
     * @param {number} [slot] The optional slot ID, or zero if no slot
     *     is specified.
     * @param {number} join The join ID.
     * @param {boolean} value The value.
     */

    /**
     * This event is raised when a digital (discrete) value is sent to
     * the remote device, either as a result of the `sendDigital()`
     * function or the `toggleDigital()` function.
     *
     * @event Connection#digitalSent
     * @param {number} [slot] The optional slot ID, or zero if no slot
     *     is specified.
     * @param {number} join The join ID.
     * @param {boolean} value The value.
     */

    /**
     * This event is raised when analog input data is received from the
     * remote device.
     *
     * @event Connection#analog
     * @param {number} [slot] The optional slot ID, or zero if no slot
     *     is specified.
     * @param {number} join The join ID.
     * @param {number} value The value.
     */

    /**
     * This event is raised when an analog value is sent to the remote
     * device as a result of the `sendAnalog()` function.
     *
     * @event Connection#analogSent
     * @param {number} [slot] The optional slot ID, or zero if no slot
     *     is specified.
     * @param {number} join The join ID.
     * @param {number} value The value.
     */

    /**
     * This event is raised when serial (string) input data is received
     * from the remote device.
     *
     * @event Connection#serial
     * @param {number} [slot] The optional slot ID, or zero if no slot
     *     is specified.
     * @param {number} join The join ID.
     * @param {string} value The value.
     */

    /**
     * This event is raised when a serial (string) value is sent to the
     * remote device as a result of the `sendSerial()` function.
     *
     * @event Connection#serialSent
     * @param {number} [slot] The optional slot ID, or zero if no slot
     *     is specified.
     * @param {number} join The join ID.
     * @param {string} value The value.
     */

    // Set default values for parameters.
    hbInterval = hbInterval || 1000;
    hbTimeout = hbTimeout || 3000;

    // Declare private variables. We store these in an object 'p' partly
    // to prevent variable name collision in functions that take
    // arguments of the same name, and partly for readability, so that
    // all private variables accessed in the code appear as 'p.foo'.
    var p = {
        handle      : 0,        // {number} 16 bit connection handle
        hbCount     : 0,        // {number} heartbeat time counter in msec
        hbError     : false,    // {boolean} true if heartbeat error
        hbInterval  : hbInterval, // {number} heartbeat interval in msec
        hbTimeout   : hbTimeout, // {number} heartbeat timeout in msec
        hostname    : hostname, // {String} hostname of remote device
        input       : null,     // {Buffer} unprocessed network data
        ip          : null,     // {String} IP address of remote device
        ipid        : ipid,     // {number} IPID of remote device
        ipBytes     : null,     // {array} remote IP as array of bytes
        isConnected : false,    // {boolean} true if connected AND valid
                                //     connection handle received
        port        : port,     // {number} port number of remote device
        repeats     : {},       // {Object} table of repeating commands
        socket      : null,     // {Socket} socket for remote device
        ssl         : ssl,      // {boolean} true to use SSL
        supportsHB  : false,    // {boolean} true if remove device
                                //     supports heartbeats
        timer       : null,     // {number} background timer ID
        togglers    : {}        // {Object} lookup table of toggle timers
    };

    // Various constants used in the CNX network protocol.
    const GREETING_PACKET_OUT       = 1;
    const GREETING_PACKET_IN        = 2;
    const DISCONNECT_PACKET         = 3;
    const ERROR_PACKET              = 4;
    const DATA_PACKET               = 5;
    const WARNING_PACKET            = 8;
    const GATEWAY_PERCENT_PACKET    = 9;
    const AUTH_PACKET               = 11;
    const AUTH_RESPONSE_PACKET      = 12;
    const HEARTBEAT_PACKET_OUT      = 13;
    const HEARTBEAT_PACKET_IN       = 14;
    const READINESS_PACKET          = 15;

    // Save off a reference to 'this' so we can still access it inside
    // functions that bind 'this' to something else (so we don't have
    // to jump through crazy explicit binding hoops).
    var self = this;

    // Forward-declare some private functions.
    var sendRepeatingPacket;

    /**
     * Stores the IP address of the remote device, as a string in `p.ip`
     * and as a four-byte Buffer in `p.ipBytes`. This function is called
     * either from the `connect()` function (if it was passed an IP 
     * address) or from `p.socket`'s `lookup` event (if `connect()` was
     * passed a hostname that was resolved via DNS).
     *
     * @param {String} ip The IP address of the remote device.
     *
     * @private
     */
    var setIp = function(ip) {
        p.ip = ip;
        var matches = ip.match(/^(\d+)\.(\d+)\.(\d+)\.(\d+)$/);
        p.ipBytes = [ matches[1], matches[2], matches[3], matches[4] ];
    }

    /**
     * Sends a packet to the remote device via `p.socket`. The
     * appropriate 3-byte header is sent, followed by the specified
     * payload. The header contains the packet type code and the
     * 16-bit payload length. This function must *not* be called if
     * `isConnected` is `false`.
     *
     * @param {number} type The 8-bit packet type code.
     * @param {Buffer} payload The packet payload data.
     *
     * @private
     */
    var sendPacket = function(type, payload) {
        var packet = Buffer.alloc(3 + payload.length);
        packet[0] = type;
        packet[1] = payload.length >> 8;
        packet[2] = payload.length & 0xFF;
        for (var i = 0; i < payload.length; ++i) {
            packet[3 + i] = payload[i];
        }
        p.socket.write(packet);
    }

    /**
     * Shuts down the connection, and optionally emits an `error` event
     * with the specified error message.
     *
     * @param {String} [msg] A message describing the error. If omitted,
     *     no error is signalled.
     *
     * @private
     */
    var shutdown = function(msg) {
        if (p.socket) {
            if (msg) {
                self.emit('error', new Error(msg));
            }
            p.socket.destroy();
        }
    }

    /**
     * Calls `setIp()` to store the DNS-resolved IP address of the
     * remote device.
     *
     * @param {String} err An error message string, or `null` if no
     *     error occurred.
     * @param {String} address The IP address of the remote device.
     *
     * @private
     */
    var onSocketLookup = function(err, address) {
        if (!err) {
            setIp(address);
        }
    }

    /**
     * Sends a greeting packet to the remote device.
     *
     * @private
     */
    var onSocketConnect = function() {
        var payload = Buffer.alloc(7);
        payload[0] = p.ipBytes[0];
        payload[1] = p.ipBytes[1];
        payload[2] = p.ipBytes[2];
        payload[3] = p.ipBytes[3];
        payload[4] = p.ipid >> 8;
        payload[5] = p.ipid & 0xFF;
        payload[6] = 0x40; // ???
        sendPacket(GREETING_PACKET_OUT, payload);
    }

    /**
     * At regular intervals, checks whether the time since last heartbeat
     * packet from the remote device exceeds the allowable threshold; if
     * so, an `error` event is emitted. Also sends heartbeat packets out
     * to the remote device at regular intervals. Finally, honors any
     * registered repeating-digital commands.
     *
     * @private
     */
    var onTimer = function() {
        if (!p.isConnected) return;
        if (p.hbInterval > 0) {
            p.hbCount += 10;
            if (p.hbCount >= p.hbTimeout && !p.hbError) {
                p.hbError = true;
                self.emit('error',
                    new Error('heartbeat timeout error occurred'));
            }
            if ((p.hbCount % p.hbInterval) === 0) {
                var payload = Buffer.alloc(2);
                payload[0] = p.handle >> 8;
                payload[1] = p.handle % 0xFF;
                sendPacket(HEARTBEAT_PACKET_OUT, payload);
            }
        }
        for (var key in p.repeats) {
            p.repeats[key].counter += 10;
            if ((p.repeats[key].counter % 500) === 0) {
                sendRepeatingPacket(
                    p.repeats[key].join,
                    p.repeats[key].slot,
                    true);
            }
        }
    }

    /**
     * Decodes and handles a greeting packet. The supplied stream handle
     * is saved in `p.handle`. If the remote device indicates that
     * authentication is required, an authentication packet is sent.
     * Otherwise, `p.isConnected` is set to `true`, and the `connect`
     * event is emitted.
     *
     * @param {Buffer} payload The packet's payload bytes.
     *
     * @private
     */
    var onGreetingPacket = function(payload) {
        if (payload.length >= 4) {
            p.supportsHB = (payload[3] & 1) === 1;
            if (p.supportsHB) {
                p.timer = setInterval(onTimer, 10);
            }
        }
        p.handle = (payload[0] << 8) + payload[1];
        if ((payload[2] && 0x80) === 0) {
            switch (payload[2] & 0x1F) {
                case 2: return shutdown('CNX not in table');
                case 3: return shutdown('CNX not CIP node');
                case 4: return shutdown('CNX no license');
            }
        }
        if ((payload[2] && 0x40) != 0) {
            var s = (p.username || '') + ':' + (p.password || '');
            var length = s.length;
            var payload = Buffer.alloc(2 + length);
            payload[0] = p.handle >> 8;
            payload[1] = p.handle & 0xFF;
            for (var i = 0; i < length; ++i) {
                buffer[2 + i] = s[i];
            }
            sendPacket(AUTH_PACKET, payload);
        } else if (!p.isConnected) {
            p.isConnected = true;
            self.emit('connect');
        }
    }

    /**
     * Decodes and handles a normal-disconnect packet. This function calls
     * `shutdown()` to close the connection.
     *
     * @param {Buffer} payload The packet's payload bytes.
     *
     * @private
     */
    var onDisconnectPacket = function(payload) {
        p.handle = (payload[0] << 8) + payload[1];
        shutdown();
    }

    /**
     * Decodes and handles an error packet. This function calls
     * `shutdown()` to close the connection and emit an `error` event
     * with message text depending on the packet's error type code.
     *
     * @param {Buffer} payload The packet's payload bytes.
     *
     * @private
     */
    var onErrorPacket = function(payload) {
        p.handle = (payload[0] << 8) + payload[1];
        var message = 'unknown error';
        switch (payload[3]) {
            case 0:
                message = 'client disconnected successfully';
                break;
            case 1:
                message = 'server closed';
                break;
            case 2:
                message = 'CIP node not responding';
                break;
            case 3:
                message = 'invalid handler';
                break;
            case 4:
                message = 'timed out';
                break;
            case 5:
                message = 'timing error, data transmitted ' +
                    'too fast for receiver';
                break;
        }
        shutdown(message);
    }

    /**
     * Decodes and handles a data packet. This function decodes the
     * incoming data and emits appropriate events (`analog`, `digital` or
     * `serial`).
     *
     * @param {Buffer} payload The packet's payload bytes.
     *
     * @private
     */
    var onDataPacket = function(payload) {
        p.handle = (payload[0] << 8) + payload[1];
        var extra = 0;
        var slot = 0;
        var join = 0;
        var value;
        if (payload[3] == 0x20) {
            slot = payload[4];
            extra = 3;
        }
        if (payload[2] <= 0) return;
        switch (payload[3 + extra]) {
            case 0:
                if (payload[2 + extra] === 3) {
                    join = (payload[5 + extra] << 8) +
                        payload[4 + extra];
                    join &= 0x7FFF;
                    join++;
                    value = (payload[5 + extra] & 0x80) != 0x80;
                    self.emit('digital', slot, join, value);
                }
                break;
            case 1:
            case 20:
                value = 0;
                switch (payload[2 + extra]) {
                    case 3:
                        join = payload[4 + extra];
                        value = payload[5 + extra];
                        break;
                    case 4:
                        join = payload[4 + extra];
                        value = (payload[5 + extra] << 8) +
                            payload[6 + extra];
                        break;
                    case 5:
                        join = (payload[4 + extra] << 8) +
                            payload[5 + extra];
                        value = (payload[6 + extra] << 8) +
                            payload[7 + extra];
                        break;
                }
                join++;
                self.emit('analog', slot, join, value);
                break;
            case 2:
                if (payload[4 + extra] != 0x23) {
                    break;
                }
                var a = 5 + extra;
                var b = a + payload[2 + extra] - 2;
                while (a <= b) {
                    join = 0;
                    value = '';
                    while (payload[a] >= 0x30 &&
                            payload[a] <= 0x39) {
                        join = join * 10 + payload[a++] - 0x30;
                    }
                    a++;
                    while (a < b && payload[a] != 13) {
                        value = value + String.fromCharCode(payload[a++]);
                    }
                    self.emit('serial', slot, join, value);
                    a += 2;
                }
                break;
            case 0x12:
                value = '';
                join = payload[4 + extra];
                join++;
                var size = payload[2 + extra] - 2;
                var index = 5 + extra;
                var count = 0;
                while (count < size) {
                    value = value + String.fromCharCode(payload[index++]);
                    count++;
                }
                self.emit('serial', slot, join, value);
                break;
            case 0x15:
                value = '';
                join = (payload[4 + extra] << 8) + payload[5 + extra];
                join++;
                var size = payload[2 + extra] - 4;
                var index = 7 + extra;
                var count = 0;
                while (count < size) {
                    value = value + String.fromCharCode(payload[index++]);
                    count++;
                }
                self.emit('serial', slot, join, value);
                break;
        }
    }

   /**
     * Decodes and handles a warning packet. This function emits an `error`
     * event with message text depending on the packet's warning status
     * code. This function does _not_ close the connection.
     *
     * @param {Buffer} payload The packet's payload bytes.
     *
     * @private
     */
    var onWarningPacket = function(payload) {
        p.handle = (payload[0] << 8) + payload[1];
        var message = 'unknown error';
        switch (payload[3]) {
            case 0:
                message = 'buffer is normal';
                break;
            case 1:
                message = 'buffer size is reaching maximum limit; ' +
                    'stop sending data';
                break;
            case 2:
                message = 'buffer size returned to safe zone; ' +
                    'client can continue to send data';
                break;
            case 3:
                message = 'buffer had been exceeded; packet was lost';
                break;
        }
        self.emit('error', new Error(message));
    }

    /**
     * Decodes and handles a gateway percent packet (???). This function
     * emits an `error` event, but does not close the connection.
     *
     * @param {Buffer} payload The packet's payload bytes.
     *
     * @private
     */
    var onGatewayPercentPacket = function(payload) {
        p.handle = (payload[0] << 8) + payload[1];
        var message = 'gateway percent error ' + payload[2];
        self.emit('error', new Error(message));
    }

    /**
     * Decodes and handles an authentication response packet. If
     * authentication was successful, the `connect` event is emitted;
     * otherwise, the `error` and `close` events are emitted and the
     * connection is closed.
     *
     * @param {Buffer} payload The packet's payload bytes.
     *
     * @private
     */
    var onAuthResponsePacket = function(payload) {
        p.handle = (payload[0] << 8) + payload[1];
        if (!payload[2]) {
            return shutdown('authentication failed');
        }
        self.emit('connect', new Error());
    }

    /**
     * Decodes and handles a heartbeat packet. This function resets the
     * heartbeat error flag `p.hbError` and time-since-last-heartbeat
     * counter `p.hbCount`.
     *
     * @param {Buffer} payload The packet's payload bytes.
     *
     * @private
     */
    var onHeartbeatPacket = function(payload) {
        p.handle = (payload[0] << 8) + payload[1];
        p.hbError = false;
        p.hbCount = 0;
    }

    /**
     * Decodes and handles a readiness packet. This function confirms that
     * the supplied readiness code indicates that the remote device is
     * ready, and calls `shutdown()` if not.
     *
     * @param {Buffer} payload The packet's payload bytes.
     *
     * @private
     */
    var onReadinessPacket = function(payload) {
        if (payload[0] != 2) {
            shutdown('program not ready');
        }
    }

    /**
     * Handles an incoming packet, dispatching it to the apporpriate
     * function for the specified packet type. This function catches
     * any exceptions thrown by the packet type handler functions and
     * calls `shutdown()` if an error occurs.
     *
     * @param {number} type The packet type code.
     * @param {Buffer} payload The packet's payload bytes.
     *
     * @private
     */
    var processPacket = function(type, payload) {
        try {
            switch (type) {
                case GREETING_PACKET_IN:
                    return onGreetingPacket(payload);
                case DISCONNECT_PACKET:
                    return onDisconnectPacket(payload);
                case ERROR_PACKET:
                    return onErrorPacket(payload);
                case DATA_PACKET:
                    return onDataPacket(payload);
                case WARNING_PACKET:
                    return onWarningPacket(payload);
                case GATEWAY_PERCENT_PACKET:
                    return onGatewayPercentPacket(payload);
                case AUTH_RESPONSE_PACKET:
                    return onAuthResponsePacket(payload);
                case HEARTBEAT_PACKET_IN:
                    return onHeartbeatPacket(payload);
                case READINESS_PACKET:
                    return onReadinessPacket(payload);
                default:
                    return;
            }
        }
        catch (err) {
            shutdown('invalid packet received');
        }
    }

    /**
     * Handles raw incoming network data. The data is first appended to
     * the unprocessed input buffer, and then any fully-formed packets
     * in the buffer are passed to `processPacket()`.
     *
     * @param {Buffer} data The incoming network data.
     *
     * @private
     */
    var onSocketData = function(data) {
        // Append the new data to any already-buffered data.
        var n = p.input.length + data.length;
        p.input = Buffer.concat([p.input, data], n);

        // Parse all complete packets.
        var consumed = 0;
        while (p.input.length >= consumed + 3) {
            n = p.input.readUInt16BE(consumed + 1);
            if (p.input.length < 3 + n + consumed) break;
            processPacket(p.input[consumed],
                p.input.slice(consumed + 3, consumed + 3 + n));
            consumed += 3 + n;
        }

        // Discard any processed data.
        if (consumed > 0) {
            p.input = p.input.slice(consumed);
        }
    }

    /**
     * Emits the `error` event.
     *
     * @param {String} err A network socket error message.
     *
     * @private
     */
    var onSocketError = function(err) {
        self.emit('error', err);
    }

    /**
     * Resets all internal state variables, shuts down any active
     * timers, and emits the `close` event.
     *
     * @private
     */
    var onSocketClose = function() {
        if (p.timer) clearInterval(p.timer);
        for (var key in p.togglers) {
            clearTimeout(p.togglers[key].timer);
        }
        p.togglers      = {};
        p.handle        = null;
        p.hbCount       = 0;
        p.hbError       = false;
        p.input         = null;
        p.ip            = null;
        p.ipBytes       = null;
        p.isConnected   = false;
        p.socket        = null;
        p.supportsHB    = false;
        p.timer         = null;
        self.emit('close');
    }

    /**
     * The IP address of the remote device, or `null` if the connection
     * is not active.
     *
     * @type String
     * @name Connection#ipAddress
     */
    Object.defineProperty(this, 'ipAddress', {
        get: function() { return p.ip; }
    });

    /**
     * `true` if a connection to the remote device is open and
     * established (i.e., valid packets and a valid stream handle have
     * been received).
     *
     * @type String
     * @name Connection#isConnected
     */
    Object.defineProperty(this, 'isConnected', {
        get: function() { return p.isConnected; }
    });

    /**
     * The IPID of the remote device.
     *
     * @type number
     * @name Connection#ipid
     */
    Object.defineProperty(this, 'ipid', {
        get: function() { return p.ipid; }
    });

    /**
     * The port number of the remote device.
     *
     * @type number
     * @name Connection#port
     */
    Object.defineProperty(this, 'port', {
        get: function() { return p.port; }
    });

    /**
     * Begins a connection attempt to a remote device. The connection
     * parameters passed to this function are optional; if specified,
     * they permanently override the parameters passed to the constructor.
     *
     * If the connection is successful, the `connect` event is emitted. If
     * the connection fails, an `error` event is emitted, followed by a
     * `close` event.
     *
     * This function does nothing if a connection is already established
     * or if a connection attempt is in progress.
     *
     * @param {String} [hostname] The IP address or hostname of the remote
     *     device.
     * @param {number} [ipid] The remote device's "IPID" identifier.
     * @param {String} [username] The optional authentication username.
     * @param {String} [password] The optional authentication password.
     * @param {number} [port] The port number of the remote device.
     * @param {boolean} [ssl] `true` to use SSL (NOT SUPPORTED; IGNORED).
     * @param {number} [hbInterval] The interval at which to send heartbeat
     *     packets to the remote device, in milliseconds. This value is
     *     optional and defaults to 1000 milliseconds.
     * @param {number} [hbTimeout] Abort the connection if a heartbeat
     *     packet is not received from the remote device within this time
     *     interval, in milliseconds. This value is otpional and defaults
     *     to 3000 milliseconds.
     *
     * @function Connection#connect
     */
    this.connect = function(hostname, ipid, username, password, port) {

        if (p.socket) return;

        // Set connection settings if parameters passed in.
        p.hbInterval = hbInterval || p.hbInterval;
        p.hbTimeout = hbTimeout || p.hbTimeout;
        p.hostname  = hostname || p.hostname;
        p.ipid      = ipid || p.ipid;
        p.port      = port || p.port;

        // Validate all required parameters.
        if (!p.hostname) throw new Error('ip/hostname not specified');
        if (!p.ipid) throw new Error('ipid not specified');
        if (!p.port) throw new Error('port not specified');

        // Start a connection attempt.
        p.input = Buffer.alloc(0);
        p.socket = new net.Socket();
        p.socket.on('lookup',     onSocketLookup);
        p.socket.on('connect',    onSocketConnect);
        p.socket.on('data',       onSocketData);
        p.socket.on('error',      onSocketError);
        p.socket.on('close',      onSocketClose);
        p.socket.connect(p.port, p.hostname);

        // If the hostname given is an IP address, `p.socket`'s
        // `lookup` event will not be raised, so we need to save off
        // the "resolved" IP here.
        if (/^\d+\.\d+\.\d+\.\d+$/.test(p.hostname)) {
            setIp(p.hostname);
        }
    }

    /**
     * Sends an analog value to the remote device. This function does
     * nothing if the connection is not established.
     *
     * @param {number} join The join ID of the value to set.
     * @param {number} value The value to set.
     * @param {number} [slot] The optional slot ID of the value to set.
     *
     * @function Connection#sendAnalog
     */
    this.sendAnalog = function(join, value, slot) {
        if (!p.isConnected) return;
        if (join <= 0 || join > 0xFFFF) return;
        var payload;
        if (p.supportsHB || join > 0x7F) {
            var extra = slot > 0 ? 3 : 0;
            payload = Buffer.alloc(8 + extra);
            payload[0] = p.handle >> 8;
            payload[1] = p.handle & 0xFF;
            payload[2] = 5 + extra;
            if (slot > 0) {
                payload[3] = 0x20;
                payload[4] = slot & 0xFF;
                payload[5] = 5
            }
            payload[3 + extra] = 20;
            payload[4 + extra] = (join - 1) >> 8;
            payload[5 + extra] = (join - 1) & 0xFF;
            payload[6 + extra] = value >> 8;
            payload[7 + extra] = value & 0xFF;
        } else {
            var extra = slot > 0 ? 3 : 0;
            payload = Buffer.alloc(7 + extra);
            payload[0] = p.handle >> 8;
            payload[1] = p.handle & 0xFF;
            payload[2] = 4 + extra;
            if (slot > 0) {
                payload[3] = 0x20;
                payload[4] = slot & 0xFF;
                payload[5] = 4
            }
            payload[3 + extra] = 1;
            payload[4 + extra] = (join - 1) >> 8;
            payload[5 + extra] = (join - 1) & 0xFF;
            payload[6 + extra] = value & 0xFF;
        }
        sendPacket(DATA_PACKET, payload);
        self.emit('analogSent', slot || 0, join, value);
    }

    /**
     * Sends a digital value to the remote device. This function does
     * nothing if the connection is not established.
     *
     * @param {number} join The join ID of the value to set.
     * @param {boolean} value The value to set.
     * @param {number} [slot] The optional slot ID of the value to set.
     *
     * @function Connection#sendDigital
     */
    this.sendDigital = function(join, value, slot) {
        if (!p.isConnected) return;
        if (join <= 0 || join > 0xFFFF) return;
        var extra = slot > 0 ? 3 : 0;
        var payload = Buffer.alloc(6 + extra);
        payload[0] = p.handle >> 8;
        payload[1] = p.handle & 0xFF;
        payload[2] = 3 + extra;
        if (slot > 0) {
            payload[3] = 0x20;
            payload[4] = slot & 0xFF;
            payload[5] = 3;
        }
        payload[3 + extra] = 0;
		--join;
        payload[4 + extra] = join >> 8;
        if (!value) {
            payload[5 + extra] = (join & 0xFF) | 0x80;
        } else {
            payload[5 + extra] = join & 0xFF;
        }
        sendPacket(DATA_PACKET, payload);
        self.emit('digitalSent', slot || 0, join + 1, value);
    }

    /**
     * Toggles a digital value by immediately setting the specified
     * value, waiting for the specified amount of time, and then
     * setting the opposite value. If another toggle is pending for
     * the same join/slot combination, that toggle is terminated without
     * sending the second command, and the new toggle value is immediately
     * sent. This function does nothing if the connection is not
     * established.
     *
     * @param {number} join The join ID of the value to toggle.
     * @param {boolean} value The value to set.
     * @param {number} [delay=10] The delay time before sending the
     *     second toggle value, in milliseconds. The default delay is
     *     10 milliseconds.
     * @param {number} [slot] The optional slot ID of the value to set.
     *
     * @function Connection#toggleDigital
     */
    this.toggleDigital = function(join, value, delay, slot) {
        var key = join + ',' + slot;
        if (p.togglers[key]) {
            clearTimeout(p.togglers[key].timer);
            delete p.togglers[key];
        }
        self.sendDigital(join, value, slot);
        p.togglers[key] = {
            timer: setTimeout(function() {
                self.sendDigital(join, !value, slot);
                delete p.togglers[key];
            }, delay || 10)
        };
    }

    /**
     * Sends a serial (string) value to the remote device. This function
     * does nothing if the connection is not established.
     *
     * @param {number} join The join ID of the value to set.
     * @param {String} value The value to set.
     * @param {number} [slot] The optional slot ID of the value to set.
     *
     * @function Connection#sendSerial
     */
    this.sendSerial = function(join, value, slot) {
        if (!p.isConnected) return;
        if (join <= 0 || join > 0xFFFF) return;
        var payload;
        if (join > 0x7F || p.supportsHB) {
            var extra = slot > 0 ? 3 : 0;
            var length = value.length;
            if (length > 0x7B) length = 0x7B;
            payload = Buffer.alloc(7 + length + extra);
            payload[0] = p.handle >> 8;
            payload[1] = p.handle & 0xFF;
            payload[2] = length + 4 + extra;
            if (slot > 0) {
                payload[3] = 0x20;
                payload[4] = slot & 0xFF;
                payload[5] = length + 4;
            }
            payload[3 + extra] = 0x15;
            payload[4 + extra] = (join - 1) >> 8;
            payload[5 + extra] = (join - 1) & 0xFF;
            payload[6 + extra] = 1;
            for (var i = 0; i < length; ++i) {
                buffer[i + 7 + extra] = value[i] & 0xFF;
            }
        } else {
            var extra = slot > 0 ? 3 : 0;
            var length = value.length;
            if (length > 0x7B) length = 0x7B;
            payload = Buffer.alloc(5 + length + extra);
            payload[0] = p.handle >> 8;
            payload[1] = p.handle & 0xFF;
            payload[2] = length + 2 + extra;
            if (slot > 0) {
                payload[3] = 0x20;
                payload[4] = slot & 0xFF;
                payload[5] = length + 2;
            }
            payload[3 + extra] = 0x12;
            payload[4 + extra] = (join - 1);
            for (var i = 0; i < length; ++i) {
                buffer[i + 5 + extra] = value[i] & 0xFF;
            }
        }
        sendPacket(DATA_PACKET, payload);
        self.emit('serialSent', slot || 0, join, value);
    }

    sendRepeatingPacket = function(join, slot, value) {
        if (!p.isConnected) return;
        if (join <= 0 || join > 0xFFFF) return;
        var extra = slot > 0 ? 3 : 0;
        var payload = Buffer.alloc(6 + extra);
        payload[0] = p.handle >> 8;
        payload[1] = p.handle & 0xFF;
        payload[2] = 3 + extra;
        if (slot > 0) {
            payload[3] = 0x20;
            payload[4] = slot & 0xFF;
            payload[5] = 3;
        }
        payload[3 + extra] = 0x27;
        payload[4 + extra] = (join - 1) >> 8;
        if (!value) {
            payload[5 + extra] = ((join - 1) & 0xFF) | 0x80;
        } else {
            payload[5 + extra] = (join - 1) & 0xFF;
        }
        sendPacket(DATA_PACKET, payload);
    }

    /**
     * Begins sending repetitive digital (discrete) values to the remote
     * device at regular intervals. This function does nothing if a
     * repetitive command is already active for the specified slot/join or
     * if the connection is not established.
     *
     * @param {number} join The join ID of the value to set.
     * @param {number} [slot] The optional slot ID of the value to set.
     *
     * @function Connection#startRepeatingDigital
     */
    this.startRepeatingDigital = function(join, slot) {
        slot = slot || 0;
        var key = join + ',' + slot;
        p.repeats[key] = { join: join, slot: slot, counter: 0 };
        sendRepeatingPacket(join, slot, true);
    }

    /**
     * Stops sending repetitive digital (discrete) values to the remote
     * device at regular intervals. This function does nothing if no
     * repetitive command is active for the specified slot/join or if the
     * connection is not established.
     *
     * @param {number} join The join ID of the value to set.
     * @param {number} [slot] The optional slot ID of the value to set.
     *
     * @function Connection#stopRepeatingDigital
     */
    this.stopRepeatingDigital = function(join, slot) {
        slot = slot || 0;
        var key = join + ',' + slot;
        sendRepeatingPacket(join, slot, false);
        delete p.repeats[key];
    }

    /**
     * Sends an update request packet to the remote device, asking it to
     * send back data packets with all analog, digital and serial (string)
     * values. This function does nothing if the connection is not
     * established.
     *
     * @function Connection#updateRequest
     */
    this.updateRequest = function() {
        if (!p.isConnected) return;
        var payload = Buffer.alloc(5);
        payload[0] = p.handle >> 8;
        payload[1] = p.handle % 0xFF;
        payload[2] = 2;
        payload[3] = 3;
        payload[4] = 0;
        sendPacket(DATA_PACKET, payload);
    }

    /**
     * Disconnects from the remote device. When the connection is closed,
     * this object emits the `close` event. This function does nothing
     * if the connection is already closed.
     *
     * @function Connection#disconnect
     */
    this.disconnect = function() {
        shutdown();
    }
}

util.inherits(Connection, events.EventEmitter);

module.exports = {
    Connection: Connection
};
